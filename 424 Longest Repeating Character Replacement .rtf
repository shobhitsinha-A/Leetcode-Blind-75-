{\rtf1\ansi\ansicpg1252\cocoartf2706
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 .SFNS-Regular_wdth_opsz120000_GRAD_wght1F40000;\f1\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red29\green29\blue29;\red255\green255\blue255;\red0\green0\blue0;
\red0\green0\blue255;\red32\green108\blue135;\red101\green76\blue29;\red0\green0\blue109;\red15\green112\blue1;
\red19\green118\blue70;\red157\green0\blue210;}
{\*\expandedcolortbl;;\cssrgb\c14902\c14902\c14902;\cssrgb\c100000\c100000\c100000;\cssrgb\c0\c0\c0;
\cssrgb\c0\c0\c100000;\cssrgb\c14902\c49804\c60000;\cssrgb\c47451\c36863\c14902;\cssrgb\c0\c6275\c50196;\cssrgb\c0\c50196\c0;
\cssrgb\c3529\c52549\c34510;\cssrgb\c68627\c0\c85882;}
\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\fs36 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 424\'a0Longest Repeating Character Replacement
\f1\fs26 \cf0 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 class\cf0 \strokec4  \cf6 \strokec6 Solution\cf0 \strokec4 :\cb1 \
\pard\pardeftab720\partightenfactor0
\cf0 \cb3     \cf5 \strokec5 def\cf0 \strokec4  \cf7 \strokec7 characterReplacement\cf0 \strokec4 (\cf8 \strokec8 self\cf0 \strokec4 , \cf8 \strokec8 s\cf0 \strokec4 : \cf6 \strokec6 str\cf0 \strokec4 , \cf8 \strokec8 k\cf0 \strokec4 : \cf6 \strokec6 int\cf0 \strokec4 ) -> \cf6 \strokec6 int\cf0 \strokec4 :\cb1 \
\
\cb3         count = \{\} \cf9 \strokec9 #count freq of aplhabets \cf0 \cb1 \strokec4 \
\cb3         res =\cf10 \strokec10 0\cf0 \cb1 \strokec4 \
\
\cb3         l=\cf10 \strokec10 0\cf0 \cb1 \strokec4 \
\
\cb3         \cf11 \strokec11 for\cf0 \strokec4  r \cf5 \strokec5 in\cf0 \strokec4  \cf7 \strokec7 range\cf0 \strokec4 (\cf7 \strokec7 len\cf0 \strokec4 (s)):\cb1 \
\
\cb3             count[s[r]] = \cf10 \strokec10 1\cf0 \strokec4 + count.get(s[r],\cf10 \strokec10 0\cf0 \strokec4 )\cb1 \
\
\cb3             \cf11 \strokec11 while\cf0 \strokec4  (r-l+\cf10 \strokec10 1\cf0 \strokec4 ) - \cf7 \strokec7 max\cf0 \strokec4 (count.values())> k:\cb1 \
\
\cb3                 count[s[l]]-=\cf10 \strokec10 1\cf0 \cb1 \strokec4 \
\
\cb3                 l+=\cf10 \strokec10 1\cf0 \strokec4  \cf9 \strokec9 # dercrease wondow size and \cf0 \cb1 \strokec4 \
\
\cb3             res = \cf7 \strokec7 max\cf0 \strokec4 (res,r-l+\cf10 \strokec10 1\cf0 \strokec4 ) \cf9 \strokec9 #res, current window \cf0 \cb1 \strokec4 \
\cb3         \cb1 \
\cb3         \cf11 \strokec11 return\cf0 \strokec4  res\cb1 \
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\cb3         \cf9 \strokec9 # #neetcode code approach \cf0 \cb1 \strokec4 \
\cb3         \cf9 \strokec9 # #create a hashmap count to keep count of incoming character\cf0 \cb1 \strokec4 \
\cb3         \cf9 \strokec9 # # if length of window minus max freq of element in window is greater than k then first \cf0 \cb1 \strokec4 \
\cb3         \cf9 \strokec9 # #remove the first caharacter in the window and then increment l\cf0 \cb1 \strokec4 \
\
\cb3         \cf9 \strokec9 # count = \{\}\cf0 \cb1 \strokec4 \
\cb3         \cf9 \strokec9 # l=0\cf0 \cb1 \strokec4 \
\cb3         \cf9 \strokec9 # res=0\cf0 \cb1 \strokec4 \
\
\cb3         \cf9 \strokec9 # for r in range(len(s)):\cf0 \cb1 \strokec4 \
\cb3         \cf9 \strokec9 #     count[s[r]] = 1 + count.get(s[r],0)\cf0 \cb1 \strokec4 \
\
\cb3         \cf9 \strokec9 #     if (r-l+1) - max(count.values()) > k:\cf0 \cb1 \strokec4 \
\cb3         \cf9 \strokec9 #         count[s[l]]-=1\cf0 \cb1 \strokec4 \
\cb3         \cf9 \strokec9 #         l+=1\cf0 \cb1 \strokec4 \
\
\cb3         \cf9 \strokec9 #     res = max(res,r-l+1)\cf0 \cb1 \strokec4 \
\
\cb3         \cf9 \strokec9 # return res  \cf0 \cb1 \strokec4 \
\
\
\
\
\
\
\cb3         \cf9 \strokec9 # count = \{\}\cf0 \cb1 \strokec4 \
\cb3         \cf9 \strokec9 # res = 0\cf0 \cb1 \strokec4 \
\cb3         \cf9 \strokec9 # l = 0\cf0 \cb1 \strokec4 \
\
\cb3         \cf9 \strokec9 # for r in range(len(s)):\cf0 \cb1 \strokec4 \
\cb3         \cf9 \strokec9 #     count[s[r]] = 1 + count.get(s[r],0)\cf0 \cb1 \strokec4 \
\
\cb3         \cf9 \strokec9 #     if (r-l+1) - max(count.values()) > k:\cf0 \cb1 \strokec4 \
\cb3         \cf9 \strokec9 #         count[s[l]] -=1\cf0 \cb1 \strokec4 \
\cb3         \cf9 \strokec9 #         l+=1\cf0 \cb1 \strokec4 \
\cb3             \cb1 \
\cb3         \cf9 \strokec9 #     res = max(res, r-l+1)\cf0 \cb1 \strokec4 \
\cb3         \cb1 \
\cb3         \cf9 \strokec9 # return res\cf0 \cb1 \strokec4 \
\
\cb3         \cf9 \strokec9 #more efficient calculate maxf \cf0 \cb1 \strokec4 \
\
\cb3         \cf9 \strokec9 # count = \{\}\cf0 \cb1 \strokec4 \
\cb3         \cf9 \strokec9 # res = 0\cf0 \cb1 \strokec4 \
\cb3         \cf9 \strokec9 # l = 0\cf0 \cb1 \strokec4 \
\cb3         \cf9 \strokec9 # maxf = 0\cf0 \cb1 \strokec4 \
\cb3         \cf9 \strokec9 # for r in range(len(s)):\cf0 \cb1 \strokec4 \
\cb3         \cf9 \strokec9 #     count[s[r]] = 1 + count.get(s[r],0)\cf0 \cb1 \strokec4 \
\cb3         \cf9 \strokec9 #     maxf = max(maxf,count[s[r]])\cf0 \cb1 \strokec4 \
\
\cb3         \cf9 \strokec9 #     if (r-l+1) - maxf > k:\cf0 \cb1 \strokec4 \
\cb3         \cf9 \strokec9 #         count[s[l]] -=1\cf0 \cb1 \strokec4 \
\cb3         \cf9 \strokec9 #         l+=1\cf0 \cb1 \strokec4 \
\cb3             \cb1 \
\cb3         \cf9 \strokec9 #     res = max(res, r-l+1)\cf0 \cb1 \strokec4 \
\cb3         \cb1 \
\cb3         \cf9 \strokec9 # return res\cf0 \cb1 \strokec4 \
}